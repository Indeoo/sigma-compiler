package org.example;

import org.example.runner.SigmaRunner;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

public class CompilerApp {
    private static final String SAMPLE_CODE = """
                int x = 10;
                println("Hello, Sigma!");
                int y = x + 10;
                println(y);
                """;

    public static void main(String[] args) {
        SigmaCompiler compiler = new SigmaCompiler();
        SigmaRunner runner = new SigmaRunner();

        // Support quick recursive-descent syntax check without ANTLR.
        // Usage: --rd <file>
        if (args.length >= 2 && ("--rd".equals(args[0]) || "-rd".equals(args[0]))) {
            String filename = args[1];
            try {
                String src = Files.readString(Paths.get(filename));
                java.util.List<String> errs = org.example.parser.RecursiveDescentParser.parseAndCollectErrors(src);
                if (errs.isEmpty()) {
                    System.out.println("No syntax errors (recursive-descent check)");
                } else {
                    System.err.println("Syntax errors (recursive-descent):");
                    for (String e : errs) System.err.println(e);
                    System.exit(1);
                }
            } catch (Exception e) {
                System.err.println("Failed to read file for rd parse: " + e.getMessage());
                System.exit(2);
            }
            return;
        }

        // Dump tokens for debugging: --dump-tokens <file>
        if (args.length >= 2 && ("--dump-tokens".equals(args[0]) || "-dt".equals(args[0]))) {
            String filename = args[1];
            try {
                String src = Files.readString(Paths.get(filename));
                java.util.List<String> toks = org.example.parser.RecursiveDescentParser.dumpTokens(src);
                System.out.println("Token dump for: " + filename);
                for (String t : toks) System.out.println(t);
            } catch (Exception e) {
                System.err.println("Failed to read file for token dump: " + e.getMessage());
                System.exit(2);
            }
            return;
        }

        if (args.length == 0) {
            // Interactive mode - simple example
            System.out.println("Sigma Compiler - Interactive Mode");

            // Step 1: Compile
            CompilationResult result = compiler.compile(SAMPLE_CODE);

            // Step 2: Handle compilation result
            if (!result.isSuccessful()) {
                System.err.println("Compilation failed:");
                System.err.println(result.getAllMessagesAsString());
                return;
            }

            // Debug output
            System.out.println("Compilation successful!");
            System.out.println("Generated bytecode length: " + result.getBytecode().length);
            System.out.println("Class name: " + result.getClassName());

            // Step 3: Execute (separate responsibility)
            try {
                System.out.println("Starting execution...");
                runner.run(result);
                System.out.println("Execution completed.");
            } catch (Exception e) {
                System.err.println("Execution failed: " + e.getMessage());
                e.printStackTrace();
            }

        } else {
            // File mode or script mode
            for (String filename : args) {
                Path p = Paths.get(filename);
                System.out.println("[debug] initial path: " + p + ", exists=" + Files.exists(p));
                // If the path doesn't exist as provided, try resolving relative to the JVM working directory
                if (!Files.exists(p)) {
                    // Walk upward from user.dir to find the file in ancestor directories (handles Gradle module cwd)
                    Path cwd = Paths.get(System.getProperty("user.dir"));
                    Path found = null;
                    Path probe = cwd;
                    while (probe != null) {
                        Path candidate = probe.resolve(filename);
                        if (Files.exists(candidate) && Files.isRegularFile(candidate)) {
                            found = candidate;
                            break;
                        }
                        probe = probe.getParent();
                    }
                    if (found != null) {
                        System.out.println("[debug] resolved via ancestor search to: " + found);
                        p = found;
                    } else {
                        System.out.println("[debug] file not found in ancestor search from user.dir=" + System.getProperty("user.dir"));
                    }
                }

                if (Files.exists(p) && Files.isRegularFile(p)) {
                    try {
                        List<String> lines = Files.readAllLines(p, StandardCharsets.UTF_8);
                        if (looksLikeCommandScript(lines)) {
                            System.out.println("Executing script: " + filename);
                            processScriptFile(p, lines, compiler, runner);
                            continue;
                        }
                    } catch (IOException e) {
                        System.err.println("Failed to read file '" + filename + "': " + e.getMessage());
                        // fallback to compiling as source below
                    }
                }

                // Default: treat as Sigma source file. Prefer the resolved path 'p' if it exists.
                Path compilePath = Files.exists(p) ? p : Paths.get(filename);
                System.out.println("Compiling: " + compilePath);
                CompilationResult result = compiler.compileFile(compilePath.toString());

                // Handle compilation result
                if (!result.isSuccessful()) {
                    System.err.println("Compilation of " + filename + " failed:");
                    System.err.println(result.getAllMessagesAsString());
                    continue; // Try next file
                }

                // Execute
                System.out.println("Executing: " + filename);
                try {
                    runner.run(result);
                } catch (Exception e) {
                    System.err.println("Execution of " + filename + " failed: " + e.getMessage());
                }
            }
        }
    }

    /**
     * Heuristically determine if a file is a command script (contains directives) rather than plain Sigma source.
     */
    private static boolean looksLikeCommandScript(List<String> lines) {
        for (String raw : lines) {
            String line = raw.strip();
            if (line.isEmpty() || line.startsWith("#")) continue;
            if (line.startsWith("//")) continue;
            // Recognize simple directives: runfile, runcode, compile (script directives)
            if (line.startsWith("runfile ") || line.startsWith("runcode") || line.startsWith("compile ") || line.startsWith("print ")) {
                return true;
            }
            // continue scanning other lines; treat as source only if no directives are found
        }
        return false;
    }

    /**
     * Process a command script file. Supported directives (one per line):
     * - runfile <path>       : compile and run the Sigma source file at <path>
     * - compile <path>       : compile only (no run)
     * - runcode <code>       : compile and run the inline code on the same line
     * - runcode <<           : start a heredoc; continue reading lines until a line with '>>' and treat the content as code
     * - print <text>         : print the rest of the line to stdout
     * Lines starting with '#' are treated as comments.
     */
    private static void processScriptFile(Path scriptPath, List<String> lines, SigmaCompiler compiler, SigmaRunner runner) {
        // First pass: collect prelude declarations (const and top-level function declarations) so they are visible to later inline blocks
        StringBuilder prelude = new StringBuilder();
        boolean[] isPreludeLine = new boolean[lines.size()];
        for (int i = 0; i < lines.size(); i++) {
            String raw = lines.get(i);
            String line = raw.strip();
            if (line.startsWith("//") || line.startsWith("#") || line.isEmpty()) continue;

            // skip runcode blocks/heredoc when collecting top-level declarations
            if (line.startsWith("runcode <<")) {
                // skip until '>>'
                i++;
                for (; i < lines.size(); i++) {
                    if (lines.get(i).strip().equals(">>")) break;
                }
                continue;
            }
            if (line.startsWith("runcode")) {
                // skip following block lines until next directive (simple heuristic)
                i++;
                for (; i < lines.size(); i++) {
                    String s = lines.get(i).strip();
                    if (s.startsWith("print ") || s.startsWith("runfile ") || s.startsWith("compile ") || s.startsWith("runcode")) {
                        i--;
                        break;
                    }
                }
                continue;
            }

            // collect const declarations
            if (line.startsWith("const ")) {
                prelude.append(line).append('\n');
                isPreludeLine[i] = true;
                continue;
            }

            // collect top-level function declarations only (heuristic: function starts at column with type/name and ends with '{')
            if (line.contains("(") && line.contains(")") && line.endsWith("{")) {
                int depth = 0;
                int j = i;
                for (; j < lines.size(); j++) {
                    String l = lines.get(j);
                    prelude.append(l).append('\n');
                    isPreludeLine[j] = true;
                    for (char c : l.toCharArray()) {
                        if (c == '{') depth++;
                        else if (c == '}') depth--;
                    }
                    if (depth <= 0) break;
                }
                i = j; // continue outer loop after function body
            }
        }

    // Second pass: execute script lines, skipping prelude lines; prelude contains top-level declarations preserved for blocks
        for (int i = 0; i < lines.size(); i++) {
            if (isPreludeLine[i]) continue;
            String raw = lines.get(i);
            String line = raw.strip();
            if (line.isEmpty() || line.startsWith("#") || line.startsWith("//")) continue;

            if (line.startsWith("print ")) {
                System.out.println(line.substring("print ".length()));
                continue;
            }

            if (line.startsWith("runfile ")) {
                String target = line.substring("runfile ".length()).strip();
                Path targetPath = scriptPath.getParent() != null ? scriptPath.getParent().resolve(target) : Paths.get(target);
                System.out.println("Script: runfile " + targetPath);
                CompilationResult result = compiler.compileFile(targetPath.toString());
                if (!result.isSuccessful()) {
                    System.err.println("Compilation of " + target + " failed:");
                    System.err.println(result.getAllMessagesAsString());
                    continue;
                }
                try {
                    runner.run(result);
                } catch (Exception e) {
                    System.err.println("Execution failed for " + target + ": " + e.getMessage());
                }
                continue;
            }

            // Implicit Sigma statement block: gather consecutive Sigma-like lines and append to accumulated program
            if (looksLikeSigmaStatement(line)) {
                StringBuilder sb = new StringBuilder();
                sb.append(line).append('\n');
                int j = i + 1;
                for (; j < lines.size(); j++) {
                    String next = lines.get(j).strip();
                    if (next.isEmpty() || next.startsWith("#")) break;
                    if (next.startsWith("//")) continue;
                    if (next.startsWith("print ") || next.startsWith("runfile ") || next.startsWith("compile ") || next.startsWith("runcode")) break;
                    sb.append(next).append('\n');
                }
                i = j - 1; // advance outer loop
                System.out.println("Script: implicit runcode block - executing. Block content:\n" + sb.toString());
                if (System.getenv("SIGMA_SCRIPT_DEBUG") != null) {
                    System.out.println("--- Prelude + block to compile ---\n" + prelude.toString() + "\n" + sb.toString());
                }
                runInlineCode(compiler, runner, prelude.toString(), sb.toString());
                continue;
            }

            if (line.startsWith("compile ")) {
                String target = line.substring("compile ".length()).strip();
                Path targetPath = scriptPath.getParent() != null ? scriptPath.getParent().resolve(target) : Paths.get(target);
                System.out.println("Script: compile " + targetPath);
                CompilationResult result = compiler.compileFile(targetPath.toString());
                if (!result.isSuccessful()) {
                    System.err.println("Compilation of " + target + " failed:");
                    System.err.println(result.getAllMessagesAsString());
                } else {
                    System.out.println("Compilation successful: " + target);
                }
                continue;
            }

            if (line.startsWith("runcode ")) {
                String code = line.substring("runcode ".length());
                System.out.println("Script: runcode (inline)");
                if (System.getenv("SIGMA_SCRIPT_DEBUG") != null) {
                    System.out.println("--- Prelude + inline to compile ---\n" + prelude.toString() + "\n" + code);
                }
                runInlineCode(compiler, runner, prelude.toString(), code);
                continue;
            }

            if (line.equals("runcode")) {
                StringBuilder sb = new StringBuilder();
                int j = i + 1;
                for (; j < lines.size(); j++) {
                    String next = lines.get(j);
                    String stripped = next.strip();
                    if (stripped.startsWith("print ") || stripped.startsWith("runfile ") || stripped.startsWith("compile ") || stripped.startsWith("runcode")) break;
                    if (stripped.startsWith("#") || stripped.startsWith("//")) continue;
                    sb.append(next).append('\n');
                }
                i = j - 1;
                System.out.println("Script: runcode (block) - executing\n" + sb.toString());
                if (System.getenv("SIGMA_SCRIPT_DEBUG") != null) {
                    System.out.println("--- Prelude + block to compile ---\n" + prelude.toString() + "\n" + sb.toString());
                }
                runInlineCode(compiler, runner, prelude.toString(), sb.toString());
                continue;
            }

            if (line.equals("runcode <<")) {
                StringBuilder sb = new StringBuilder();
                i++; // move to next line
                for (; i < lines.size(); i++) {
                    String l = lines.get(i);
                    if (l.strip().equals(">>")) break;
                    sb.append(l).append('\n');
                }
                String code = sb.toString();
                System.out.println("Script: runcode (heredoc) - executing block");
                if (System.getenv("SIGMA_SCRIPT_DEBUG") != null) {
                    System.out.println("--- Prelude + heredoc to compile ---\n" + prelude.toString() + "\n" + code);
                }
                runInlineCode(compiler, runner, prelude.toString(), code);
                continue;
            }

            // Unknown directive - warn
            System.err.println("Unknown script directive: '" + line + "' in " + scriptPath);
        }

        // All runcode blocks are executed immediately as they are encountered.
    }

    private static void runInlineCode(SigmaCompiler compiler, SigmaRunner runner, String prelude, String code) {
        String full = prelude == null || prelude.isEmpty() ? code : (prelude + "\n" + code);
        CompilationResult res = compiler.compile(full);
        if (!res.isSuccessful()) {
            System.err.println("Compilation failed for inline code:");
            System.err.println(res.getAllMessagesAsString());
            return;
        }
        try {
            runner.run(res);
        } catch (Exception e) {
            System.err.println("Execution failed for inline code: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static boolean looksLikeSigmaStatement(String line) {
        // Simple heuristics: statement ends with ';' or contains '=' or starts with 'int ' or 'println'
        // exclude script directives
        if (line.startsWith("runcode") || line.startsWith("runfile") || line.startsWith("compile") || line.startsWith("print")) return false;
        if (line.endsWith(";")) return true;
        if (line.contains("=")) return true;
        if (line.startsWith("int ") || line.startsWith("double ") || line.startsWith("String ") || line.startsWith("boolean ")) return true;
        if (line.startsWith("println(")) return true;
        return false;
    }

}
