package org.sigma.runner;

import org.sigma.compiler.CompilationResult;

import java.lang.reflect.Method;

/**
 * Runner for executing compiled Sigma programs.
 * Executes JVM bytecode using ClassLoader and reflection.
 */
public class SigmaRunner {

    /**
     * Execute a successfully compiled Sigma program
     *
     * @param result the compilation result containing JVM bytecode
     * @throws IllegalArgumentException if the compilation result is not successful
     * @throws RuntimeException if execution fails
     */
    public void run(CompilationResult result) {
        if (!result.isSuccessful()) {
            throw new IllegalArgumentException("Cannot run failed compilation. Compilation errors: " +
                                             result.getAllMessagesAsString());
        }

        // Display warnings if any
        if (result.hasWarnings()) {
            System.err.println("Compilation warnings:");
            result.getAllWarnings().forEach(warning -> System.err.println("Warning: " + warning));
        }

        try {
            runBytecode(result.getBytecode(), result.getClassName());
        } catch (Exception e) {
            throw new RuntimeException("Execution failed: " + e.getMessage(), e);
        }
    }

    /**
     * Execute compiled bytecode by loading it into the JVM and calling main method
     *
     * @param bytecode the compiled JVM bytecode
     * @param className the name of the class containing the main method
     * @throws RuntimeException if execution fails
     */
    public void runBytecode(byte[] bytecode, String className) {
        if (bytecode == null) {
            throw new IllegalArgumentException("Bytecode cannot be null");
        }
        if (className == null || className.isEmpty()) {
            throw new IllegalArgumentException("Class name cannot be null or empty");
        }

        try {
            // For debugging: write the generated class to disk so we can disassemble it if needed
            try (java.io.FileOutputStream fos = new java.io.FileOutputStream(className + ".class")) {
                fos.write(bytecode);
            } catch (Exception e) {
                System.err.println("Warning: failed to write class file for debugging: " + e.getMessage());
            }

            // Print disassembly via ASM TraceClassVisitor for debugging
            // Disabled by default; enable with -Dsigma.disasm=true
            try {
                if (Boolean.getBoolean("sigma.disasm")) {
                    org.objectweb.asm.ClassReader cr = new org.objectweb.asm.ClassReader(bytecode);
                    java.io.PrintWriter pw = new java.io.PrintWriter(System.out);
                    org.objectweb.asm.util.TraceClassVisitor tcv = new org.objectweb.asm.util.TraceClassVisitor(pw);
                    cr.accept(tcv, 0);
                    pw.flush();
                }
            } catch (Exception e) {
                System.err.println("Warning: failed to disassemble bytecode: " + e.getMessage());
            }

            // Create a custom ClassLoader to load our generated bytecode
            ClassLoader classLoader = new ByteCodeClassLoader(bytecode, className);

            // Load the class
            Class<?> clazz = classLoader.loadClass(className);

            // Get the main method
            Method mainMethod = clazz.getMethod("main", String[].class);

            // Execute the main method
            mainMethod.invoke(null, (Object) new String[0]);

        } catch (Exception e) {
            throw new RuntimeException("Execution error: " + e.getMessage(), e);
        }
    }

    /**
     * Custom ClassLoader to load bytecode from memory
     */
    private static class ByteCodeClassLoader extends ClassLoader {
        private final byte[] bytecode;
        private final String className;

        public ByteCodeClassLoader(byte[] bytecode, String className) {
            this.bytecode = bytecode;
            this.className = className;
        }

        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            if (name.equals(className)) {
                return defineClass(name, bytecode, 0, bytecode.length);
            }
            return super.findClass(name);
        }
    }

    /**
     * Execute a Sigma program from compilation result, handling errors gracefully
     *
     * @param result the compilation result
     * @return true if execution was successful, false if there were errors
     */
    public boolean runSafely(CompilationResult result) {
        try {
            run(result);
            return true;
        } catch (Exception e) {
            System.err.println("Execution failed: " + e.getMessage());
            return false;
        }
    }
}