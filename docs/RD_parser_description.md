Опис реалізації синтаксичного аналізатора методом рекурсивного спуску (recursive‑descent parser)

Мета

Цей документ описує програмну реалізацію рекурсивного‑спускового синтаксичного аналізатора (РДС‑парсер) для мови Sigma (або подібної простої мови). Цей текст можна використовувати як технічну документацію або скопіювати в README проекту.

Коротка оглядова ідея

Рекурсивний‑спусковий парсер складається з трьох основних частин. Перша частина — лексер (tokenizer), який розбиває вхідний текст на послідовність токенів (ідентифікатори, числа, рядки, оператори, пунктуація та EOF) і зберігає позиції (рядок, колонку). Друга частина — набір методів‑рекурсій, що відображають продукції граматики; кожен метод розпізнає певний нетермінал (наприклад, statement, expression, primary). Третя частина — модель AST: класи вузлів (CompilationUnit, Statement, Expression, Binary, Call, Identifier, Literal тощо).

Клієнтський API

Рекомендовані публічні методи включають parseAndCollectErrors(String src) → List<String>, який виконує лише перевірку синтаксису і повертає список рядкових повідомлень про помилки, та parseToAst(String src) → ParseAstResult { ast, errors }, який повертає AST (навіть частково) і перелік помилок. Корисним доповненням може бути dumpTokens(String src) → List<String> для допоміжного виводу токенів при налагодженні.

Контракт (inputs/outputs)

Вхідний аргумент — сирцевий рядок (UTF‑8). Повертаються AST та/або перелік помилок. Повідомлення про помилки мають містити номер рядка (і за потреби колонку) та короткий опис. Успіх позначається порожнім списком помилок. Під час виявлення помилок парсер намагається ресинхронізуватися, щоб знайти додаткові помилки далі у файлі і не завершувати розбір після першої помилки.

Структура токена

Кожен токен зберігає тип TokenType (наприклад, IDENT, INT, FLOAT, STRING, KEYWORD, OP, PUNC, EOF), текстове представлення токена, позицію у вигляді рядка і колонки, а також опційну підказку hint (наприклад, для можливих опечаток ключових слів).

Токенізація — важливі деталі

Пробіли та однорядкові коментарі "//" пропускаються. Для блочних коментарів /* ... */ у разі відсутності закриваючої послідовності "*/" лексер додає підказку "Unterminated block comment" і просувається на наступний рядок, щоб не «поїдати» весь файл. Рядкові літерали при відсутності закриваючих лапок отримують підказку "Unterminated string literal" і лексер проскакує до кінця поточного рядка. Багатосимвольні оператори (<=, >=, ==, !=, &&, ||, **) розпізнаються перед односимвольними. Для ідентифікаторів виконується перевірка на наявність у наборі ключових слів; якщо відстань Левенштейна до якогось ключового слова становить ≤ 1, додається підказка (suggestion) і зберігається hint, що дозволяє повідомити про ймовірну опечатку, наприклад "prontln" → "println".

Граматика (спрощена, в EBNF)

Нижче наведено спрощену граматику для виразів і операторів (розширюйте під потреби мови):

CompilationUnit ::= { Statement }
Statement ::= VariableDeclaration ';' | ExpressionStatement | DirectiveStatement
VariableDeclaration ::= Type IDENT [ '=' Expression ]
Type ::= 'int' | 'double' | 'String' | 'boolean' | ...
ExpressionStatement ::= Expression ';'
DirectiveStatement ::= ('runcode' | 'runfile' | 'compile') ( STRING | Expression ) ';'

Expression ::= LogicalOr
LogicalOr ::= LogicalAnd { '||' LogicalAnd }
LogicalAnd ::= Relational { '&&' Relational }
Relational ::= Additive { ('<' | '>' | '<=' | '>=' | '==' | '!=') Additive }
Additive ::= Multiplicative { ('+'|'-') Multiplicative }
Multiplicative ::= Power { ('*'|'/'|'%') Power }
Power ::= Unary [ '^' Power ]     // right-associative
Unary ::= '!' Unary | '-' Unary | Primary
Primary ::= INT | FLOAT | STRING | IDENT [ '(' [ ArgList ] ')' ] | '(' Expression ')'
ArgList ::= Expression { ',' Expression }

Примітка: оператор степеня (power) повинен бути реалізований як правосторонній (right‑associative); наприклад, parsePower рекурсивно викликає parsePower для правого операнда.

Реалізація методів парсера — прикладні поради

Рекомендується виділяти окремі методи для кожного рівня пріоритету, наприклад parseAdditive(), parseMultiplicative(), parsePower(), parseUnary(), parsePrimary(). Для ліво‑асоціативних операторів реалізуйте цикл: отримавши лівий операнд через виклик наступного рівня, у циклі перевіряйте наявність оператора, парсіть правий операнд і будуйте злитий вузол Binary. Для правосторонніх операторів (^) при виявленні '^' рекурсивно викликайте parsePower() для правого дочірнього виразу. Метод parsePrimary має розпізнавати літерали, ідентифікатори та виклики функцій; у разі запису IDENT( парсити список аргументів.

Обробка помилок та ресинхронізація

Після виявлення синтаксичної помилки (наприклад, очікується вираз після оператора '+') слід записати повідомлення з номером рядка. Далі важливо намагатися ресинхронізуватися, щоб продовжити розбір і знайти інші помилки. Практичні стратегії включають пошук межі оператора (наприклад, наступної крапки з комою ';') і пропуск до неї, або, якщо така межа не знайдена, просування на один токен (idx = idx + 1) замість стрибка на кінець файлу — це менш руйнівна стратегія, що дозволяє виявити більше помилок. Лексер повинен додавати підказки для непарних блокових коментарів і непарних рядкових літералів і просуватися до наступного рядка; інакше він може «поїдати» решту файлу і наступні токени ніколи не будуть згенеровані.

Підказки (fuzzy suggestions)

Підказки реалізуються на рівні токенізації: якщо для ідентифікатора, що не є ключовим словом, відстань Левенштейна до деякого ключового слова дорівнює 1, то в токен додається hint. На рівні парсера це дозволяє вивести дружню підказку, наприклад: "Did you mean 'println' instead of 'prontln'?".

Перевірка асоціативності операторів

Після побудови AST слід перевіряти форму виразів на відповідність правилам асоціативності. Для оператора '^' лівий дочірній вузол не повинен бути '^' (вираз виду (a ^ b) ^ c є некоректним для правостороннього оператора). Для лівих операторів (+, -, *, /, %) перевірте, щоб правий дочірній вузол не був тим же оператором у формі a + (b + c). У разі невідповідності додавайте відповідне повідомлення з прив’язкою до рядка.

Повернення помилок — формат

У терміналі зручним форматом є рядки виду "Line N: <опис помилки>". Наприклад: "Line 12: Expected expression after '+'" або "Line 6: Did you mean 'runcode' instead of 'runcod'?". Додатково можна виводити рядок контексту і caret‑покажчик під ним для точнішої локалізації помилки.

Інтеграція з існуючим проектом

Якщо в проекті існує клас `RecursiveDescentParser` з методами `parseAndCollectErrors(String)` та `parseToAst(String)`, інтегруйте виклик цих методів у CLI точку входу (наприклад, `CompilerApp`) так, щоб при аргументі `--rd <file>` застосовувався рекурсивно‑спусковий парсер і результати виводилися у stderr/stdout. Перед застосуванням парсера до великих блоків коду (скриптові директиви) можна збирати попередні оголошення у prelude і додавати їх до коду, що перевіряється.

Обмеження та подальші поліпшення

Поточна стратегія ресинхронізації (шукати ';', і якщо не знайдено — просунутися на один токен) є простою і працездатною, але може створювати додатковий шум. Можна покращити алгоритм ресинхронізації, додавши эвристики (наприклад, ресинхронізація на ключових словах або на початку наступного виразного блоку). Для багаторядкових конструкцій (heredoc, незавершені блоки) доцільно ввести спеціальні стани лексера. Рекомендується додати unit‑тести: для кожного кейсу у `syntax_error_tests.sigma` створити тест, який перевіряє очікуваний набір помилок.

Приклад використання (псевдокод)

1) Перевірка синтаксису файлу:

List<String> errors = RecursiveDescentParser.parseAndCollectErrors(src);
if (!errors.isEmpty()) {
  System.err.println("Syntax errors (recursive-descent):");
  for (String e : errors) System.err.println(e);
}

2) Отримати AST і помилки:

ParseAstResult res = RecursiveDescentParser.parseToAst(src);
Ast.CompilationUnit cu = res.ast;
List<String> errors = res.errors;

3) Для дебага: вивести токени

List<String> toks = RecursiveDescentParser.dumpTokens(src);
for (String t : toks) System.out.println(t);

Приклади типових повідомлень про помилки

Line 12: Expected expression after '+'
Line 15: Unexpected token '@'
Line 18: Missing semicolon at end of statement
Line 83: Unterminated string literal
Line 6: Did you mean 'runcode' instead of 'runcod'?

План тестування

Нижче наведена таблична план‑матриця тестів (тип випробування, очікуваний результат і орієнтовна кількість кейсів). Таблиця охоплює юніт‑ та інтеграційні категорії і може бути розширена при додаванні нових конструкцій мови.

| № | Тип випробування | Очікуваний результат | Кількість випробувань |
|---:|---|---|---:|
| 1 | Пропуск термінала (відсутній `;` або `)`) | Повідомлення про відсутність термінала, локалізація та ресинхронізація до наступного оператора | 4 |
| 2 | Зайвий термінал (подвійні/троякі `;`, зайві `,`) | Повідомлення про зайвий символ або пусту інструкцію, не призводить до зупинки парсера | 3 |
| 3 | Помилка у наборі ключового слова (опечатка, наприклад `runcod`) | Підказка (Did you mean ...) та повідомлення про невідоме слово | 3 |
| 4 | Неправильний оператор у виразах (наприклад `@`, `1 + * 3`) | Повідомлення про очікуваний вираз/неприпустимий оператор, ресинхронізація | 4 |
| 5 | Невірна форма числа (lone dot, multiple dots, hex/рамки) | Повідомлення про некоректний числовий літерал | 3 |
| 6 | Перевірка пріоритетності операторів (класичні пріоритети) | AST відповідної форми для правильних виразів; для некоректних — помилка пріоритету або очікуваного операнда | 4 |
| 7 | Перевірка асоціативності (право vs ліво, наприклад `^`) | Повідомлення про порушення асоціативності там, де потрібно | 3 |
| 8 | Непарний рядковий літерал (unterminated string) | Підказка "Unterminated string literal", токенізатор перескакує на кінець рядка і парсер продовжує | 3 |
| 9 | Непарний блочний коментар (`/* ...` без `*/`) | Підказка "Unterminated block comment" і просування на наступний рядок; парсер продовжує | 2 |
| 10 | Відсутня кома в списку аргументів або зайва кома (trailing comma) | Очікуване повідомлення про ',' або ')' в аргументах; ресинхронізація | 3 |
| 11 | Вкладені конструкції та незакриті дужки/фігурні дужки | Повідомлення про незакриту дужку/блок і спроба ресинхронізації; перевірка, що парсер продовжує | 4 |
| 12 | Погана escape‑послідовність у рядку | Повідомлення про недопустимий escape і локалізація | 2 |
| 13 | Використання ключового слова як ідентифікатора (`int int = 5`) | Повідомлення про недопустиме використання ключового слова або помилку оголошення | 2 |
| 14 | Порожні інструкції / лише оператори (`+5;`) | Повідомлення про некоректний початок виразу або літералу; ресинхронізація | 2 |
| 15 | Одночасні множинні помилки в одному рядку (наприклад `println(,);`) | Компактне повідомлення/кілька повідомлень, але не дублювання зайвого шуму | 2 |
| 16 | Інтеграційні сценарії (повний файл `syntax_error_tests.sigma`) | Порівняння виводу парсера з «golden» файлом; тест провалюється при відмінностях | 1 |
| 17 | Стрес‑тести з довгими файлами/багато помилок | Перевірити, що парсер не падає і обмежує кількість помилок (threshold) | 2 |
| 18 | Тести на повідомлення підказки (fuzzy suggestions) | Переконатися, що для опечаток видається релевантна підказка, але не для віддалених слів | 3 |

Після таблиці: CI‑інтеграція і формат «golden» виходів. Інтеграційні тести запускають парсер у режимі перевірки (`--rd`) над набором файлів із `testdata/inputs` і порівнюють фактичний вивід із файлами у `testdata/expected`. Будь‑яка відмінність повинна спричиняти провал тесту з показом diff для швидкої діагностики. CI виконує юніт‑ і інтеграційні тести на кожному коміті, з опцією порогу максимальної кількості помилок.

Висновок

У цій лабораторній роботі реалізовано простий, але практичний рекурсивно‑спусковий синтаксичний аналізатор для мови Sigma. Реалізація складається з лексера, який генерує токени з позиційною інформацією (рядок, колонка), та набору методів‑парсерів для розбору виразів з правильною підтримкою пріоритетів і асоціативності. Парсер будує часткову AST із збереженням позицій ніодів і видає читабельні діагностичні повідомлення у форматі "Line N: <опис помилки>".

Отримані результати та можливості реалізації:
- лексер виявляє і підсвічує опечатки ключових слів (fuzzy suggestion);
- обробляються непарні рядкові літерали і блочні коментарі (з відповідними підказками про помилку);
- парсер повідомляє про відсутні операнди, відсутні крапки з комою, некоректні числові літерали та помилки у списках аргументів;
- реалізовано просту ресинхронізацію (пошук до наступної ";" або просування на один токен) для продовження розбору після помилки.

Валідація виконана на прикладі файлу `syntax_error_tests.sigma`: парсер коректно виявляє ключові категорії помилок і повертає список діагностик, придатний для виводу в термінал або для автоматичної перевірки в тестах.

Рекомендації для подальшої роботи (коротко):
1) Додати набір автоматичних тестів (golden‑output) для `syntax_error_tests.sigma` і інтегрувати їх у CI;
2) За потреби додати опційний машинозчитуваний (JSON) формат діагностик для інструментальної обробки;
3) Поліпшити стратегію ресинхронізації (наприклад, ресинхронізація також на ключові слова або початок нової декларації);
4) Розширити набір тестів на комбіновані та вкладені помилки.

Отримана реалізація є придатною як лабораторна робота: вона демонструє ключові принципи побудови лексера і рекурсивного‑спускового парсера, обробки помилок і базової інтеграції з тестами/CI.

Аналіз результатів тестування

Проведено перевірку реалізації на тестовому файлі `syntax_error_tests.sigma`. Для швидкої автоматичної валідації додано невеликий runner (`RDRegressionRunner`) і відповідний Gradle‑таск `:app:runRdRegression`, який запускає парсер і перевіряє наявність декількох ключових діагностик (наприклад, підказка для опечатки директиви, відсутня крапка з комою у виразі, непарний рядковий літерал). Результат прогону runner'а — діагностики виводяться у термінал у форматі "Line N: ..." і базова перевірка пройшла успішно.

Основні спостереження після тестування:
- парсер стабільно виявляє категорії помилок: опечатки в ключових словах (fuzzy suggestions), відсутні операнди, пропущені `;`, некоректні числові літерали, непарні рядки і незавершені блочні коментарі;
- підхід з ресинхронізацією (пошук до `;` або просування на один токен) дозволяє знайти кілька помилок у файлі без раннього завершення розбору, хоча іноді додає додатковий шум у вигляді каскадних повідомлень — це очікувана компромісна поведінка;
- асоціативність оператора степеня і виявлення порушень асоціативності працюють за заданими правилами (право‑асоціативний `^`, ліво‑асоціативні `+,-,*,/,%`).

Обмеження та зауваження щодо тестового середовища:
- У репозиторії присутні старі тести, які залежать від ANTLR‑згенерованих класів; тому запуск повного набору unit‑тестів компілюється з помилками, якщо не підключити ANTLR runtime або не забезпечити генерацію класів. Саме тому для оперативної перевірки додано незалежний runner.
- Рекомендовано додати «golden» очікуваний вивід у `testdata/expected` і інтегрувати порівняння у CI для детермінованої перевірки змін у поведінці парсера.

Перелік перевірених помилок і отримані результати

Нижче наведено перелік конкретних кейсів із `syntax_error_tests.sigma`, які були перевірені, і короткий опис отриманих діагностик:

- Опечатка в директиві (`runcod println(...)`): парсер виявив і запропонував підказку — "Did you mean 'runcode'...".
- Опечатка імені функції (`prontln(...)`): парсер надавав fuzzy‑пораду (наприклад, пропозиція 'println').
- Неповний вираз (`println(2 + );`): зафіксовано повідомлення типу "Expected expression after '+'" та супутні помилки у списку аргументів.
- Неприпустимий оператор (`println(1 @ 2);`): повідомлення про несподіваний токен '@' і, за потреби, відновлення розбору до наступного оператора.
- Пропущена крапка з комою (`println("no semicolon")`): Missing semicolon at end of statement (атрибутовано до початку інструкції).
- Суміжні літерали без роздільника (`println(1 2);`): повідомлення "Expected ',' or ')' in argument list" і помітка про несподіваний токен між літералами.
- Тести асоціативності (наприклад `(1 + (2 + 3))` та `((1 ^ 2) ^ 3)`): парсер виявив порушення очікуваної асоціативності для відповідних операторів і додав діагностики.
- Непарні рядкові літерали (кілька варіантів `"unterminated ..."`): лексер віддавав підказку "Unterminated string literal" і парсер продовжував аналіз на наступних рядках.
- Непарні блочні коментарі (`/* ...` без `*/`): лексер додавав підказку "Unterminated block comment" і просувався на наступний рядок; декілька таких випадків зафіксовано в тестовому файлі.
- Некоректні числові літерали (lone dot, multiple dots, trailing letters, напр. `.`, `1.2.3`, `01x`): лексер/парсер сигналізували про "Invalid numeric literal" або видали очікувані помилки при спробі розбору аргументів.
- Відсутня кома або зайва кома в списках аргументів (`println("a" "b")`, `println("a",)`): відповідні повідомлення "Expected ',' or ')' in argument list" або "Expected expression in argument list".

Загальний висновок по тестам: парсер коректно виявляє і класифікує більшість цільових помилок, видаючи дружні підказки для опечаток, виявляючи синтаксичні дефекти в виразах і списках аргументів, а також обробляючи непарні літерали і коментарі таким чином, щоб розбір міг продовжуватися. Деякі помилки викликають каскадні повідомлення (шум) через просту ресинхронізацію — це очікувана поведінка, яку можна пом’якшити поліпшенням ресинхронізації або фільтрацією дублюючих діагностик у постпроцесінгу.

Цей документ підсумовує практичний план реалізації та інтеграції рекурсивного‑спускового парсера в проекті: надійний лексер з відстеженням позицій, шар методів‑парсерів для кожного рівня пріоритету виразів, модель AST із метаданими позицій, а також проста, але ефективна стратегія обробки помилок і ресинхронізації. Запропонований API (`parseAndCollectErrors`, `parseToAst`, `dumpTokens`) дозволяє як інтерактивне виведення помилок у термінал, так і програмну валідацію в тестах чи CI.

Рекомендовано як наступні кроки: додати набір unit‑ та інтергаційних тестів (golden‑output для `syntax_error_tests.sigma`), інтегрувати перевірки у CI, і поступово удосконалити ресинхронізацію та формат помилок (наприклад, опційний JSON‑вивід для машинної обробки). Такий підхід забезпечить зрозумілі діагностики для користувачів і стабільну базу для подальшого розширення мови.

---
Файл підготовлено як довідковий матеріал для проекту `sigma-compiler`.
